<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Recognition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --deep-purple: #2d1b4e;
            --vivid-purple: #7c3aed;
            --electric-blue: #3b82f6;
            --cyan-accent: #22d3ee;
            --mint-green: #10b981;
            --soft-green: #34d399;
            --glow-purple: rgba(124, 58, 237, 0.4);
            --glow-blue: rgba(59, 130, 246, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0f0c29 0%, #1a1040 25%, #24243e 50%, #0f2027 100%);
            background-attachment: fixed;
            position: relative;
            overflow: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(ellipse at 20% 20%, var(--glow-purple) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, var(--glow-blue) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(16, 185, 129, 0.1) 0%, transparent 60%);
            pointer-events: none;
        }

        .container {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2.5rem;
        }

        h1 {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            background: linear-gradient(135deg, var(--cyan-accent) 0%, var(--vivid-purple) 50%, var(--soft-green) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 60px var(--glow-purple);
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1rem;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.5);
            margin-top: -1.5rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .canvas-wrapper {
            position: relative;
            padding: 4px;
            border-radius: 24px;
            background: linear-gradient(135deg, var(--vivid-purple), var(--electric-blue), var(--mint-green));
            box-shadow: 
                0 0 40px var(--glow-purple),
                0 0 80px var(--glow-blue),
                0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .canvas-inner {
            background: #0a0a0f;
            border-radius: 20px;
            padding: 20px;
        }

        #drawingCanvas {
            display: block;
            background: linear-gradient(180deg, #0d0d12 0%, #121218 100%);
            border-radius: 12px;
            cursor: crosshair;
            touch-action: none;
        }

        .button-group {
            display: flex;
            gap: 1rem;
        }

        .btn {
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            padding: 0.875rem 2rem;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--vivid-purple) 0%, var(--electric-blue) 100%);
            color: white;
            box-shadow: 0 4px 20px var(--glow-purple);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px var(--glow-purple);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--mint-green);
            color: var(--soft-green);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .prediction-display {
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .prediction-label {
            font-size: 0.875rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 0.5rem;
        }

        .prediction-value {
            font-size: 5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--soft-green) 0%, var(--cyan-accent) 50%, var(--vivid-purple) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .prediction-value.visible {
            opacity: 1;
            transform: scale(1);
        }

        .confidence {
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.5rem;
        }

        .confidence-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 0.75rem;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--mint-green), var(--cyan-accent));
            border-radius: 2px;
            width: 0%;
            transition: width 0.5s ease-out;
        }

        /* Floating particles */
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--vivid-purple);
            border-radius: 50%;
            opacity: 0.3;
            animation: float 15s infinite ease-in-out;
        }

        .particle:nth-child(1) { left: 10%; top: 20%; animation-delay: 0s; background: var(--electric-blue); }
        .particle:nth-child(2) { left: 80%; top: 30%; animation-delay: 2s; background: var(--mint-green); }
        .particle:nth-child(3) { left: 20%; top: 70%; animation-delay: 4s; background: var(--vivid-purple); }
        .particle:nth-child(4) { left: 70%; top: 80%; animation-delay: 6s; background: var(--cyan-accent); }
        .particle:nth-child(5) { left: 50%; top: 10%; animation-delay: 8s; background: var(--soft-green); }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(20px, -30px) rotate(90deg); }
            50% { transform: translate(-10px, 20px) rotate(180deg); }
            75% { transform: translate(30px, 10px) rotate(270deg); }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 2rem;
            }
            
            #drawingCanvas {
                width: 250px;
                height: 250px;
            }
            
            .btn {
                padding: 0.75rem 1.5rem;
                font-size: 0.875rem;
            }
        }
    </style>
</head>
<body>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>
    <div class="particle"></div>

    <div class="container">
        <h1>Draw a Number</h1>
        <p class="subtitle">Neural Network Recognition</p>

        <div class="canvas-wrapper">
            <div class="canvas-inner">
                <canvas id="drawingCanvas" width="280" height="280"></canvas>
            </div>
        </div>

        <div class="button-group">
            <button class="btn btn-secondary" id="clearBtn">Clear</button>
            <button class="btn btn-primary" id="predictBtn">Predict</button>
        </div>

        <div class="prediction-display">
            <span class="prediction-label">Prediction</span>
            <span class="prediction-value" id="predictionValue">?</span>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill"></div>
            </div>
            <span class="confidence" id="confidenceText"></span>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const predictBtn = document.getElementById('predictBtn');
        const predictionValue = document.getElementById('predictionValue');
        const confidenceFill = document.getElementById('confidenceFill');
        const confidenceText = document.getElementById('confidenceText');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set up canvas
        ctx.fillStyle = '#0d0d12';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 16;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        function getPosition(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const pos = getPosition(e);
            lastX = pos.x;
            lastY = pos.y;
            
            // Draw a dot for single clicks
            ctx.beginPath();
            ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getPosition(e);
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            lastX = pos.x;
            lastY = pos.y;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Mouse events
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch events
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);

        // Clear canvas
        clearBtn.addEventListener('click', () => {
            ctx.fillStyle = '#0d0d12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            predictionValue.classList.remove('visible');
            predictionValue.textContent = '?';
            confidenceFill.style.width = '0%';
            confidenceText.textContent = '';
        });

        // Predict button (placeholder - would connect to backend)
        predictBtn.addEventListener('click', async () => {
            // Get canvas image data for prediction
            const imageData = canvas.toDataURL('image/png');
            
            // Simulated prediction for demo
            // In production, this would send imageData to a Flask/FastAPI backend
            const pixels = getCanvasDataForMNIST();

            const response = await fetch("/predict", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ pixels })
            });

            const result = await response.json();

            const digit = result.prediction;
            const confidence = Math.round(result.confidence * 100);

            predictionValue.textContent = digit;
            predictionValue.classList.add('visible');
            confidenceFill.style.width = confidence + '%';
            confidenceText.textContent = `Confidence: ${confidence}%`;
        });

        // Function to get canvas data formatted for MNIST (28x28 grayscale)
        function getCanvasDataForMNIST() {
            // First, get the bounding box of the drawn digit
            const sourceCtx = canvas.getContext('2d');
            const sourceData = sourceCtx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = sourceData.data;
            
            // Find bounding box of non-black pixels
            let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
            let hasContent = false;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    // Check if pixel is not black (has content)
                    if (pixels[idx] > 20 || pixels[idx + 1] > 20 || pixels[idx + 2] > 20) {
                        hasContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (!hasContent) {
                // Return empty black image if nothing drawn
                return new Array(28 * 28).fill(0);
            }
            
            // Add small padding to bounding box
            const padding = 15;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(canvas.width - 1, maxX + padding);
            maxY = Math.min(canvas.height - 1, maxY + padding);
            
            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            
            // Create intermediate canvas to crop the digit
            const cropCanvas = document.createElement('canvas');
            const size = Math.max(boxWidth, boxHeight);
            cropCanvas.width = size;
            cropCanvas.height = size;
            const cropCtx = cropCanvas.getContext('2d');
            
            // Fill with black and center the digit
            cropCtx.fillStyle = '#000000';
            cropCtx.fillRect(0, 0, size, size);
            
            // Center the cropped region
            const offsetX = (size - boxWidth) / 2;
            const offsetY = (size - boxHeight) / 2;
            cropCtx.drawImage(canvas, minX, minY, boxWidth, boxHeight, offsetX, offsetY, boxWidth, boxHeight);
            
            // Create final 28x28 canvas (MNIST format: 20x20 digit centered in 28x28 with 4px padding)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 28;
            tempCanvas.height = 28;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Fill with black
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(0, 0, 28, 28);
            
            // Draw centered with padding (like MNIST: digit in 20x20 area with 4px border)
            tempCtx.drawImage(cropCanvas, 0, 0, size, size, 4, 4, 20, 20);
            
            // Get image data
            const imageData = tempCtx.getImageData(0, 0, 28, 28);
            const data = imageData.data;
            
            // Convert to grayscale array (0-1 values)
            const grayscale = [];
            for (let i = 0; i < data.length; i += 4) {
                // Use red channel since we're drawing white on black
                grayscale.push(data[i] / 255);
            }
            
            return grayscale;
        }
    </script>
</body>
</html>
